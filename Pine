//@version=5
strategy("Swing Failure Pattern [LuxAlgo] ‚Äî EXECUTION WRAPPER (kwin MM, only SmartTrail, dual-SFP)",
     overlay = true,
     pyramiding = 0,
     initial_capital = 300,
     commission_type = strategy.commission.percent,
     commission_value = 0.055,
     calc_on_every_tick = false,
     process_orders_on_close = true)

// =======================================================================
// =============== –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô –õ–û–ö–ê–õ–¨–ù–´–ô –õ–û–ì–ò–ö–ê–¢–û–† LUX (–±–µ–∑ volume) =====
// =======================================================================

len  = input.int(2, 'Swings', minval=1)

type piv
    float swing_prc
    int   swing_bix
    float oppos_prc
    int   oppos_bix
    bool  active
    bool  confirmed
    line  wicky_line
    label wicky_label
type swing
    int   bix
    float prc

n   = bar_index
INV = color.new(color.white, 100)

var swing swingH = swing.new()
var swing swingL = swing.new()
var piv   pivH   = piv.new()
var piv   pivL   = piv.new()

method n(float piv) => bool out = not na(piv)

// –ü–∏–≤–æ—Ç—ã –Ω–∞ —Ç–µ–∫—É—â–µ–º –¢–§
ph = ta.pivothigh(len, 1)
pl = ta.pivotlow (len, 1)

// ---- Bearish SFP (–ª–æ–∫–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞)
if ph.n()
    swingH.bix := n-1
    swingH.prc := ph
swH = swingH.prc
if high > swH and open < swH and close < swH
    if not pivH.confirmed
        pivH.wicky_line.delete(), pivH.wicky_label.delete()
    pivH := piv.new(swH, n-1, low, n, true, false)
    pivH.wicky_line  := line.new(n, high, n, swH, color=color.new(color.red, 30), width=3)
    pivH.wicky_label := label.new(n, high, style=label.style_label_down, text='SFP', textcolor=color.red, color=INV)
if pivH.active and not pivH.confirmed and close < pivH.oppos_prc
    pivH.confirmed := true
    pivH.wicky_label.set_text('SFP\n‚ñº')

// ---- Bullish SFP (–ª–æ–∫–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞)
if pl.n()
    swingL.bix := n-1
    swingL.prc := pl
swL = swingL.prc
if low < swL and open > swL and close > swL
    if not pivL.confirmed
        pivL.wicky_line.delete(), pivL.wicky_label.delete()
    pivL := piv.new(swL, n-1, high, n, true, false)
    pivL.wicky_line  := line.new(n, low, n, swL, color=color.new(color.lime, 30), width=3)
    pivL.wicky_label := label.new(n, low, style=label.style_label_up, text='SFP', textcolor=color.lime, color=INV)
if pivL.active and not pivL.confirmed and close > pivL.oppos_prc
    pivL.confirmed := true
    pivL.wicky_label.set_text('‚ñ≤\nSFP')

// =======================================================================
// =============== MAGIC: –û–ö–ù–û, GATE (15m —Ñ–∏–∫—Å), fee-—Ñ–∏–ª—å—Ç—Ä ==============
// =======================================================================

// Backtest Window (–∫–∞–∫ –≤ kwin)
useWindow     = input.bool(true, "Use window")
start_time    = input.time(timestamp("2025-08-12 18:00"), "üìÜ Cycle Start Time", confirm=true)
periodChoice  = input.string("30", "Backtest Period (days from today)", options=["30","60","180"])
daysBack      = periodChoice == "30" ? 30 : periodChoice == "60" ? 60 : 180
startDateDyn  = timestamp("UTC", year(timenow), month(timenow), dayofmonth(timenow)) - daysBack * 86400000
inDateRange   = (not useWindow) or (time >= start_time and time >= startDateDyn)

// --- 15m GATE –∏ 15m SFP (anti-repaint)
close15 = request.security(syminfo.tickerid, "15", close, barmerge.gaps_off, barmerge.lookahead_off)
low15   = request.security(syminfo.tickerid, "15", low,   barmerge.gaps_off, barmerge.lookahead_off)
high15  = request.security(syminfo.tickerid, "15", high,  barmerge.gaps_off, barmerge.lookahead_off)
pl15    = request.security(syminfo.tickerid, "15", ta.pivotlow(len, 1),  barmerge.gaps_off, barmerge.lookahead_off)
ph15    = request.security(syminfo.tickerid, "15", ta.pivothigh(len, 1), barmerge.gaps_off, barmerge.lookahead_off)

// –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π SFP –Ω–∞ 15–º: –ø—Ä–æ–∫–æ–ª –∏ –≤–æ–∑–≤—Ä–∞—Ç (–∫–∞–∫ –≤ ¬´kwin¬ª –¥—É—Ö–µ)
isBullSFP_15m = pl15 and (low15 < low15[len])  and (open > low15[len])  and (close > low15[len])
isBearSFP_15m = ph15 and (high15 > high15[len]) and (open < high15[len]) and (close < high15[len])

// –û–î–ò–ù –≤—Ö–æ–¥ –Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏–∏ –∫–∞–∂–¥–æ–≥–æ 15m –±–∞—Ä–∞
var bool canEnterLong  = true
var bool canEnterShort = true
if ta.change(close15)
    canEnterLong  := true
    canEnterShort := true

// =======================================================================
// =================== –ú–ú + SMART TRAILING ===============================
// =======================================================================

groupMM = "Position (kwin)"
riskPct          = input.float(3.0, "Risk % per trade", minval=0.1, maxval=50, step=0.1, group=groupMM)
limitQtyEnabled  = input.bool(true, "üíö Limit Max Position Qty", inline="lim", group=groupMM)
maxQtyManual     = input.float(50.0, "Max Qty", minval=0.001, step=0.001, inline="lim", group=groupMM)

// qtyStep / minOrderQty ‚Äî —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã (–Ω–µ–≤–∏–¥–∏–º—ã–µ)
var float __QTY_STEP__      = 0.01
var float __MIN_ORDER_QTY__ = 0.01

groupTrail = "Smart Trailing"
enableSmartTrail = input.bool(true, "üíö Enable Smart Trailing", group=groupTrail)
trailingPerc     = input.float(0.5, "Trailing %", minval=0.05, step=0.05, group=groupTrail)
trailingOffset   = input.float(0.4, "Trailing Offset %", minval=0.05, step=0.05, group=groupTrail)
useArmAfterRR    = input.bool(true, "üíö Arm after RR‚â•X", group=groupTrail)
armRR            = input.float(0.5, "Arm RR (R)", minval=0.1, step=0.1, group=groupTrail)
useBarTrail      = input.bool(true, "üíö Use Bar-Low/High Smart Trail", group=groupTrail)
trailLookback    = input.int(50, "Trail lookback bars", minval=1, group=groupTrail)
trailBufTicks    = input.int(40, "Trail buffer (ticks)", minval=0, group=groupTrail)

groupFees = "Fees filter"
useFeeFilter     = input.bool(true, "Filter by net profit (1R must beat fees)", group=groupFees)
takerFeeRate     = input.float(0.00055, "Taker fee rate", minval=0.0, step=0.00001, group=groupFees)
minNetProfit     = input.float(2.0, "Min expected net PnL", minval=0.0, step=0.1, group=groupFees)

groupNoise       = "Noise"
useOncePerSwing  = input.bool(true, "One trade per swing", group=groupNoise)
useOnePerBar     = input.bool(true, "One signal per bar", group=groupNoise)
barPriority      = input.string("Skip", "When both on same bar", options=["Prefer Bear","Prefer Bull","Skip"], group=groupNoise)
useDirLock       = input.bool(true, "Direction lock", group=groupNoise)

// helpers
mt = syminfo.mintick
priceRound(p) => math.round(p / mt) * mt

// swing locks
var int tradedBearSwing = na
var int tradedBullSwing = na
if not pivH.active or (pivH.active and tradedBearSwing != pivH.swing_bix)
    tradedBearSwing := na
if not pivL.active or (pivL.active and tradedBullSwing != pivL.swing_bix)
    tradedBullSwing := na

cooldownOK = true  // cooldown —É–±—Ä–∞–Ω

// --- –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ä–∞–Ω–Ω–∏–µ –º–µ—Ç–∫–∏ (Lux)
bearEarly_local = pivH.active and pivH.wicky_label.get_x() == bar_index
bullEarly_local = pivL.active and pivL.wicky_label.get_x() == bar_index

// --- –û–ë–™–ï–î–ò–ù–Å–ù–ù–´–ï –°–ò–ì–ù–ê–õ–´: –ª–æ–∫–∞–ª—å–Ω—ã–π –ò–õ–ò 15m
bearSignal_raw = bearEarly_local or isBearSFP_15m
bullSignal_raw = bullEarly_local or isBullSFP_15m

// –æ–¥–Ω–æ-–≤-–±–∞—Ä (–≤–∑–∞–∏–º–æ–∏—Å–∫–ª—é—á–µ–Ω–∏–µ) –ø—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–∞—Ö
bearSignal = bearSignal_raw
bullSignal = bullSignal_raw
if useOnePerBar and bearSignal_raw and bullSignal_raw
    if barPriority == "Prefer Bear"
        bullSignal := false
    else if barPriority == "Prefer Bull"
        bearSignal := false
    else
        bearSignal := false
        bullSignal := false

// ===== –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–π
var float longEntry  = na
var float shortEntry = na
var float longSL     = na
var float shortSL    = na
var bool  longArmed  = false
var bool  shortArmed = false

if strategy.position_size == 0
    longEntry := na, shortEntry := na
    longSL := na, shortSL := na
    longArmed := false, shortArmed := false

// ===== qty calc
roundToStep(v, step) => math.round(v/step)*step
calcQty(_entry, _sl) =>
    capital  = strategy.equity
    risk_amt = capital * (riskPct / 100.0)
    stopSize = math.abs(_entry - _sl)
    rawQty   = stopSize > 0 ? (risk_amt / stopSize) : na
    q        = na(rawQty) ? na : roundToStep(rawQty, __QTY_STEP__)
    if limitQtyEnabled and not na(q)
        q := math.min(q, maxQtyManual)
    q

// =======================================================================
// ===== –í–•–û–î–´ (Smart Trail —Å—Ä–∞–∑—É, fee-—Ñ–∏–ª—å—Ç—Ä –ø–æ 1R) =====================
// =======================================================================

// LONG
if inDateRange and bullSignal and strategy.position_size <= 0 and cooldownOK and (not useDirLock or strategy.position_size >= 0) and (not useOncePerSwing or na(tradedBullSwing)) and canEnterLong
    sl    = nz(swL, low)  // —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞, –µ—Å–ª–∏ swL –≤–¥—Ä—É–≥ na
    entry = close
    qty   = calcQty(entry, sl)
    stopSize = entry - sl
    expGross = na(qty) ? na : stopSize * qty
    expFees  = na(qty) ? na : (entry * qty * takerFeeRate * 2.0)
    okNet    = (not useFeeFilter) or (not na(expGross) and expGross - expFees >= minNetProfit)

    if not na(qty) and qty > 0 and qty >= __MIN_ORDER_QTY__ and okNet
        strategy.entry("Long SFP", strategy.long, qty=qty)
        longEntry := entry
        longSL    := sl
        longArmed := not useArmAfterRR
        if enableSmartTrail
            strategy.exit("Trail Long Smart", from_entry="Long SFP", stop=sl, trail_points=entry*(trailingPerc/100.0), trail_offset=entry*(trailingOffset/100.0))
        if useOncePerSwing and pivL.active
            tradedBullSwing := pivL.swing_bix
        canEnterLong := false

// SHORT
if inDateRange and bearSignal and strategy.position_size >= 0 and cooldownOK and (not useDirLock or strategy.position_size <= 0) and (not useOncePerSwing or na(tradedBearSwing)) and canEnterShort
    sl    = nz(swH, high)
    entry = close
    qty   = calcQty(entry, sl)
    stopSize = sl - entry
    expGross = na(qty) ? na : stopSize * qty
    expFees  = na(qty) ? na : (entry * qty * takerFeeRate * 2.0)
    okNet    = (not useFeeFilter) or (not na(expGross) and expGross - expFees >= minNetProfit)

    if not na(qty) and qty > 0 and qty >= __MIN_ORDER_QTY__ and okNet
        strategy.entry("Short SFP", strategy.short, qty=qty)
        shortEntry := entry
        shortSL    := sl
        shortArmed := not useArmAfterRR
        if enableSmartTrail
            strategy.exit("Trail Short Smart", from_entry="Short SFP", stop=sl, trail_points=entry*(trailingPerc/100.0), trail_offset=entry*(trailingOffset/100.0))
        if useOncePerSwing and pivH.active
            tradedBearSwing := pivH.swing_bix
        canEnterShort := false

// =======================================================================
// ===== –î–û–¢–Ø–ì–ò–í–ê–ù–ò–ï –°–¢–û–ü–ê –ü–û –ë–ê–†–ê–ú ======================================
// =======================================================================
if enableSmartTrail and strategy.opentrades > 0
    if useArmAfterRR
        if strategy.position_size > 0 and not longArmed and not na(longEntry) and not na(longSL)
            moved = close - longEntry
            need  = (longEntry - longSL) * armRR
            longArmed := moved >= need
        if strategy.position_size < 0 and not shortArmed and not na(shortEntry) and not na(shortSL)
            moved = shortEntry - close
            need  = (shortSL - shortEntry) * armRR
            shortArmed := moved >= need

    if useBarTrail
        buf = trailBufTicks * mt
        if strategy.position_size > 0 and longArmed
            lbLow = ta.lowest(low, trailLookback)[1]
            barTS = math.max(lbLow - buf, longSL)
            strategy.exit("Trail Long Smart", from_entry="Long SFP", stop=barTS)
        if strategy.position_size < 0 and shortArmed
            lbHigh = ta.highest(high, trailLookback)[1]
            barTS = math.min(lbHigh + buf, shortSL)
            strategy.exit("Trail Short Smart", from_entry="Short SFP", stop=barTS)
