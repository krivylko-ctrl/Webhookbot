//@version=5
strategy("kwin", overlay=true, default_qty_type=strategy.fixed, initial_capital=100)

start_time = input.time(timestamp("2025-08-04 00:00"), "ðŸ“† Cycle Start Time", confirm=true)
isActive = time >= start_time

riskReward = input.float(10.5, "TP Risk/Reward Ratio", minval=0.5, step=0.1)
sfpLen = input.int(2, "Swing Length")
riskPct = input.float(3.0, "Risk % per trade", minval=0.1, maxval=10)
zeroCommission = input.bool(false, "âœ… Ignore Commission (Ideal Backtest Mode)")

useRSIWeight   = input.bool(false, "âœ… Use RSI Weighting for Position Size")
rsiWeightPct   = input.int(50, "Position Size % if RSI is Weak", minval=10, maxval=100)
rsiPeriod      = input.int(14, "RSI Period", minval=5)
rsiOverbought  = input.int(60, "RSI > for SHORT entry")
rsiOversold    = input.int(40, "RSI < for LONG entry")

enableReentryAfterSL = input.bool(false, "âœ… Allow Re-entry After Stop-Loss")
enableTrailingTP     = input.bool(false, "âœ… Enable Trailing TP Instead of Fixed TP")
trailingPerc         = input.float(1.5, "Trailing %", minval=0.1)
trailingOffset       = input.float(1.0, "Trailing Offset %", minval=0.1)
enableSmartTrail     = input.bool(true, "âœ… Enable Smart Trailing TP")

periodChoice = input.string("30", "Backtest Period", options=["30", "60", "180"])
daysBack = periodChoice == "30" ? 30 : periodChoice == "60" ? 60 : 180
startDate = timestamp("UTC", year(timenow), month(timenow), dayofmonth(timenow)) - daysBack * 24 * 60 * 60 * 1000
inDateRange = time >= startDate

isBullSFP_15m = request.security(syminfo.tickerid, "15",
  ta.pivotlow(sfpLen, 1) and low < low[sfpLen] and open > low[sfpLen] and close > low[sfpLen])
isBearSFP_15m = request.security(syminfo.tickerid, "15",
  ta.pivothigh(sfpLen, 1) and high > high[sfpLen] and open < high[sfpLen] and close < high[sfpLen])

low_15m   = request.security(syminfo.tickerid, "15", low)
high_15m  = request.security(syminfo.tickerid, "15", high)
close_15m = request.security(syminfo.tickerid, "15", close)

var bool canEnterLong = true
var bool canEnterShort = true
if ta.change(close_15m)
    canEnterLong := true
    canEnterShort := true

capital   = strategy.equity
risk_amt  = capital * (riskPct / 100)
commissionRate = 0.0004

htfClose = request.security(syminfo.tickerid, "60", close)
htfTrendUp   = htfClose > request.security(syminfo.tickerid, "60", close[1])
htfTrendDown = htfClose < request.security(syminfo.tickerid, "60", close[1])

rsi = ta.rsi(close, rsiPeriod)
rsiLongWeak  = htfTrendDown and (rsi > rsiOversold)
rsiShortWeak = htfTrendUp and (rsi < rsiOverbought)

var float lastTrailPriceLong = na
var float lastTrailPriceShort = na

if isActive

    if isBullSFP_15m and canEnterLong and inDateRange
        sl = low_15m
        entry = close
        stopSize = entry - sl
        adjRisk = useRSIWeight and rsiLongWeak ? risk_amt * (rsiWeightPct / 100) : risk_amt
        estCommission = (adjRisk / stopSize) * entry * commissionRate
        realRisk = adjRisk - estCommission
        qty = stopSize > 0 ? (zeroCommission ? adjRisk / stopSize : realRisk / stopSize / close) : na
        tp = entry + stopSize * riskReward

        if not na(qty) and qty > 0
            strategy.entry("Long SFP", strategy.long, qty=qty)
            alert('{"type":"entry","direction":"long","qty":' + str.tostring(qty) +
                  ',"entry_price":' + str.tostring(entry) + 
                  ',"stop_loss":' + str.tostring(sl) + 
                  ',"take_profit":' + str.tostring(tp) + 
                  ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar_close)

            if enableSmartTrail
                trail1 = stopSize * 2 * 0.5
                trailPrice = close - trail1
                if na(lastTrailPriceLong) or trailPrice > lastTrailPriceLong
                    alert('{"type":"trail_update","direction":"long","new_trail_stop":' + str.tostring(trailPrice) +
                          ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar)
                    lastTrailPriceLong := trailPrice
                strategy.exit("Trail Long Smart", from_entry="Long SFP", stop=sl, trail_points=trail1, trail_offset=trail1)
            else
                strategy.exit("TP/SL Long", from_entry="Long SFP", stop=sl, limit=tp)

            canEnterLong := not enableReentryAfterSL

    if isBearSFP_15m and canEnterShort and inDateRange
        sl = high_15m
        entry = close
        stopSize = sl - entry
        adjRisk = useRSIWeight and rsiShortWeak ? risk_amt * (rsiWeightPct / 100) : risk_amt
        estCommission = (adjRisk / stopSize) * entry * commissionRate
        realRisk = adjRisk - estCommission
        qty = stopSize > 0 ? (zeroCommission ? adjRisk / stopSize : realRisk / stopSize / close) : na
        tp = entry - stopSize * riskReward

        if not na(qty) and qty > 0
            strategy.entry("Short SFP", strategy.short, qty=qty)
            alert('{"type":"entry","direction":"short","qty":' + str.tostring(qty) +
                  ',"entry_price":' + str.tostring(entry) + 
                  ',"stop_loss":' + str.tostring(sl) + 
                  ',"take_profit":' + str.tostring(tp) + 
                  ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar_close)

            if enableSmartTrail
                trail1 = stopSize * 2 * 0.5
                trailPrice = close + trail1
                if na(lastTrailPriceShort) or trailPrice < lastTrailPriceShort
                    alert('{"type":"trail_update","direction":"short","new_trail_stop":' + str.tostring(trailPrice) +
                          ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar)
                    lastTrailPriceShort := trailPrice
                strategy.exit("Trail Short Smart", from_entry="Short SFP", stop=sl, trail_points=trail1, trail_offset=trail1)
            else
                strategy.exit("TP/SL Short", from_entry="Short SFP", stop=sl, limit=tp)

            canEnterShort := not enableReentryAfterSL

// === SMART TRAIL LIVE UPDATES ===
if enableSmartTrail and strategy.opentrades > 0
    var float stopSizeGlobalLong = na
    var float stopSizeGlobalShort = na
    var float trail1 = na
    var float newTrail = na

    if strategy.position_size > 0  // LONG
        stopSizeGlobalLong := strategy.position_avg_price - strategy.opentrades.entry_price(0)
        trail1 := stopSizeGlobalLong * 2 * 0.5
        newTrail := close - trail1
        if na(lastTrailPriceLong) or newTrail > lastTrailPriceLong
            alert('{"type":"trail_update","direction":"long","new_trail_stop":' + str.tostring(newTrail) +
                  ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar)
            lastTrailPriceLong := newTrail

    if strategy.position_size < 0  // SHORT
        stopSizeGlobalShort := strategy.opentrades.entry_price(0) - strategy.position_avg_price
        trail1 := stopSizeGlobalShort * 2 * 0.5
        newTrail := close + trail1
        if na(lastTrailPriceShort) or newTrail < lastTrailPriceShort
            alert('{"type":"trail_update","direction":"short","new_trail_stop":' + str.tostring(newTrail) +
                  ',"symbol":"' + syminfo.ticker + '"}', alert.freq_once_per_bar)
            lastTrailPriceShort := newTrail

// === EXIT LOGIC ===
var bool exitSent = false
if (strategy.opentrades == 0 and strategy.closedtrades > 0 and not exitSent)
    last = strategy.closedtrades - 1
    qtyExit = strategy.closedtrades.size(last)
    ep = strategy.closedtrades.entry_price(last)
    xp = strategy.closedtrades.exit_price(last)
    dir = xp > ep ? "long" : "short"
    reason = strategy.closedtrades.profit(last) > 0 ? "tp" : "sl"
    sl = dir == "long" ? ep - (xp - ep) : ep + (ep - xp)
    tp = dir == "long" ? ep + (ep - sl) * riskReward : ep - (sl - ep) * riskReward

    alert('{"type":"exit","direction":"' + dir +
          '","reason":"' + reason +
          '","symbol":"' + syminfo.ticker +
          '","qty":' + str.tostring(qtyExit) +
          ',"entry_price":' + str.tostring(ep) +
          ',"stop_loss":' + str.tostring(sl) +
          ',"take_profit":' + str.tostring(tp) +
          '}', alert.freq_once_per_bar_close)
    exitSent := true

if strategy.opentrades > 0
    exitSent := false

// === MANUAL CLOSE ===
// alert('{"type":"manual_close","direction":"long","symbol":"ETHUSDT"}')